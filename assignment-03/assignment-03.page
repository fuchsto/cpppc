---
format: Markdown
title: Assignment 3: Iterators, Function Templates
categories: cpppc, teaching
...

**C++ Programming Course, Winter Term 2016**

# 3-0: Prerequisites

## SFINAE, enable_if



# 3-1: Designing Function Templates

Your implementations should be a combination of functions provided by the STL
and must not contain explicit loops like `for` or `while`.

You may use any algorithm interface defined in the C++11 standard.
For example, you may use `std::minmax` (C++11) in your implementations, but not
`std::for_each_n` (C++17).

References:

- [C++ Algorithm Library](http://en.cppreference.com/w/cpp/algorithm)


## 3-1-1: find_mean_rep

Implement a function template `cpppc::find_mean_rep` which accepts a range specified
by two iterators in the `InputIterator` category and returns an iterator to the
element in the range that is closest to the mean of the range.

**Function interface:**

~~~c++
template <typename InputIter>
InputIter find_mean_rep(InputIter first, InputIter last);
~~~

**Example:**

~~~c++
std::vector<int> v { 1, 2, 3, 30, 40, 50 }; // mean: 21
auto closest_to_mean_it = cpppc::find_mean_rep(v.begin(), v.end());
// -> iterator at index 3 (|21-30| = 9)
~~~

## 3-1-2: histogram

Implement a function template `cpppc::histogram` which accepts a range specified
by two iterators in the `ForwardIterator` category and replaces each value by the
number of its occurrences in the range.
Values are unique in the result histogram and ordered by their first occurrence
in the range.
The function returns an iterator past the final element in the histogram.

**Function interface:**

~~~c++
template <typename ForwardIt>
ForwardIt histogram(ForwardIt first, ForwardIt last);
~~~

**Example:**

~~~c++
std::vector<int> v { 1, 5, 5, 3, 4, 1, 5, 7 };
auto hist_end = cpppc::histogram(v.begin(), v.end());
// -> 1: 2 occurences
//    5: 3 occurences
//    5: skipped
//    ...
// -> { 2, 3, 1, 1, 1 }  <- occurrences
//      ^  ^  ^  ^  ^
//      |  |  |  |  |
//      1  5  3  4  7    <- value
//
// -> returns iterator at position 5
~~~

## 3-1-3: combine_if

Implement a function template `cpppc::histogram` which accepts

- a range specified by two iterators in the `ForwardIterator` category
- a second range of the same size specified by an iterator in the `ForwardIterator`
  category at the first element in the second range
- an output range specified by an iterator in the `OutputIterator` category at the
  first element in the output range
- a binary predicate accepting a value from the first and second range



## 3-1-4: cluster

Implement a function template `cpppc::cluster` which accepts a range specified
by two iterators in the `RandomAccessIterator` category and an arbitrary number
of predicates (functions that return `true` or `false` depending on a single value).

~~~c++
template<typename RAIter, typename Predicate>
std::vector<std::pair<RAIter>>
cluster(RAIter first, RAIter last, Predicate p0, ...);
~~~

**Example:**

~~~c++
auto clusters             = cpppc::cluster(v.begin(), v.end(), is_odd, is_prime);
auto cluster_odd_first    = clusters[0];
auto cluster_prime_first  = clusters[1];

std::for_each(cluster_odd_first, cluster_prime_first,
              [](int v) { cout << v << " "; });
cout << endl;
~~~

# 3-2: Custom Container / Iterators

Implement a sparse array container.


# 3-X: Challenges


## 3-X-1: Skip List

Implement a class template `cpppc::map` that satisfies the `std::map` container
interface based on a Skip List data structure.

References: 

- [Specification of std::map](http://en.cppreference.com/w/cpp/container/map)
- [*Skip Lists: A Probabilistic Alternative to Balanced Trees*. W. Pugh, 1990](/docs/skiplist.pdf)


## 3-X-2: List Comprehension

