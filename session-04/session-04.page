---
format: Markdown
title: Session 04
category: course notes, cpppc
...

[Code Examples for Session 04](/session-04/)

# Rule of Zero

We do not need to follow the *Rule of Three* in class template `Measurements`
from assigment 02 ([source](/assignment-02/s-02/solution/measurements.h)) because
all resource management is encapsulated in the `std::vector` member.

As `std::vector` respects the *Rule of Five*, we can safely assume that its
resources will be acquired and released automatically.

- [On Rule of Zero and move assignment](http://en.cppreference.com/w/cpp/language/move_assignment)

## Default Definitions

Every class has default/copy constructor, assignment operator and destructor
defined unless they are explicitly marked as `delete` by the programmer.

If no implementation is specified explicitly, default definitions are generated by
the compiler. These are usually based on member-wise operations.

[This example](/session-04/01-defaults/main.cc) shows a minimal implementation of
a class with default operations specified by the compiler. \
Note that there is no default definition of comparison operators.


# Iterator Concepts

Algorithms and containers are entirely decoupled concepts in the C++ Standard
Template Library. That is: algorithms are agnostic of containers and are implemented against iterator ranges, not for specific container types.

You should follow this approach as strictly as possible in your own implementations.

As an example, the `std::fill` algorithm works for any range `(first, last[`
specified by any iterator implementation that satisfies the `ForwardIterator`
concept:

~~~c++
val_t                      c_arr[NElem];
std::array<val_t, NElem>   stl_arr;
std::vector<val_t>         stl_vec(NElem);
std::list<val_t>           stl_lst(NElem);

std::fill(c_arr,           c_arr + NElem, 1.23);
std::fill(stl_arr.begin(), stl_arr.end(), 2.34);
std::fill(stl_vec.begin(), stl_vec.end(), 3.45);
std::fill(stl_lst.begin(), stl_lst.end(), 4.56);
~~~


## Iterator Categories


## STL Algorithms



# Template Parameter Deduction

- Template parameters deduced from parameter types
- Return value deduced from result type


# Custom Iterators

Example: `BucketList`

- All STL algorithms are compatible, no need to reinvent +50 algorithms for the
  user-defined class template `BucketVector`

- What if we wanted to specify a user-defined variant of an algorithm?
  $\Rightarrow$ template specialization



# Type Deduction

- The `auto` keyword
- Deduction of return types


# Template Specialization

