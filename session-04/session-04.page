---
format: Markdown
title: Session 04
category: course notes, cpppc
...

[Code Examples for Session 04](/session-04/)

# Rule of Zero

We do not need to follow the *Rule of Three* in class template `Measurements`
from assigment 02 ([source](/assignment-02/s-02/solution/measurements.h)) because
all resource management is encapsulated in the `std::vector` member.

As `std::vector` respects the *Rule of Five*, we can safely assume that its
resources will be acquired and released automatically.

- [On Rule of Zero and move assignment](http://en.cppreference.com/w/cpp/language/move_assignment)

## Default Definitions

Every class has default/copy constructor, assignment operator and destructor
defined unless they are explicitly marked as `delete` by the programmer.

If no implementation is specified explicitly, default definitions are generated by
the compiler. These are usually based on member-wise operations.

[This example](/session-04/01-defaults/main.cc) shows a minimal implementation of
a class with default operations specified by the compiler. \
Note that there is no default definition of comparison operators.


# Iterator Concepts

Algorithms and containers are entirely decoupled concepts in the C++ Standard
Template Library. That is: algorithms are agnostic of containers and are implemented against iterator ranges, not for specific container types.

You should follow this approach as strictly as possible in your own implementations.

As an example, the `std::fill` algorithm works for any range `(first, last[`
specified by any iterator implementation that satisfies the `ForwardIterator`
concept:

~~~c++
val_t                      c_arr[NElem];
std::array<val_t, NElem>   stl_arr;
std::vector<val_t>         stl_vec(NElem);
std::list<val_t>           stl_lst(NElem);

std::fill(c_arr,           c_arr + NElem, 1.23);
std::fill(stl_arr.begin(), stl_arr.end(), 2.34);
std::fill(stl_vec.begin(), stl_vec.end(), 3.45);
std::fill(stl_lst.begin(), stl_lst.end(), 4.56);
~~~


## Iterator Categories

Iterators are classified into categories as illustrated
[in this overview](http://en.cppreference.com/w/cpp/iterator#Iterator_categories).

Don't let the formal vocabulary confuse you, it is actually really simple:

When you write an algorithm that operates on iterators, you have to consider
which methods of an iterator you actually require to call.
The operations you can always rely on are those in the `InputIterator` category:


Operation    | Name                                         | Category
------------ | -------------------------------------------- | ---------------
`++it`       | prefix increment                             | InputIterator
`(void)it++` | postfix increment (with unused return value) | InputIterator
`*it`        | dereference                                  | InputIterator
`it->m`      | member dereference                           | InputIterator
`it != it2`  | inequality comparison                        | InputIterator

[full reference](http://en.cppreference.com/w/cpp/concept/InputIterator)

So if your code doesn't use operations apart from these: great! Your code will
work with just any iterator.

The next category is `ForwardIterator`. It includes all operations of the
`InputIterator` category and also provides:

Operation   | Name                   | Category
----------- | ---------------------- | ----------------
`it++`      | postfix increment      | ForwardIterator
`*it++`     | dereference            | ForwardIterator

[full reference](http://en.cppreference.com/w/cpp/concept/ForwardIterator)

... and so on. Note that `it += n` or `it[n]` are still missing. These
are only defined in the most 'powerful' `RandomAccessIterator` category.

So instead of writing `it += 2` in your algorithm, it is better to use
`++(++it)` as it this operation would work for any iterator.

Even better, use `std::advance`. It always resolves to the most effcient 
increment operation for any iterator.


**Some examples:**

The container `std::list` provides iterators in the `BidirectionalIterator`
category:

~~~c++
std::list<int> lst;
// ... initialize lst with some values ...
auto it = lst.begin();
++it;                 // <- move forward
--it;                 // <- move backwards (bidirectional)
int v = i[0];         // <- fails! Random access (operator[]) is not supported by
                      //    bidirectional iterators
it += 10              // <- fails! Corresponds to random access
std::advance(it, 10); // <- works! Programmer requested "manual" advance of the
                      //    iterator. Corresponds to invoking ++it 10 times i.e.
                      //    O(k = 10) complexity
~~~

The container `std::vector` provides iterators in the `RandomAccessIterator`
category:

~~~c++
std::vector<int> vec;
// ... initialize vec with some values ...
auto it = vec.begin();
int v   = it[10];      // <- works! Random access is provided
it     += 10;          // <- works! Corresponds to random access
std::advance(it, 10);  // <- works! Corresponds to it += 10 i.e. O(1) complexity
~~~

## STL Algorithms

First, have a look a the [complete overview of all algorithm interfaces defined in the STL](http://en.cppreference.com/w/cpp/algorithm).
Every algorithm interface specifies the required cateogory of its iterator arguments.

For example:

- `std::min_element`
  ([reference](http://en.cppreference.com/w/cpp/algorithm/min_element))
  expects iterators in the `ForwardIterator` category
- `std::sort`
  ([reference](http://en.cppreference.com/w/cpp/algorithm/sort))
  requires random access iterators.


How algorithms check iterator categories at compile time:

> Yes, looks insane, but it's actually not as complicated as it looks at first

~~~c++
// Iterator class provides public type `iterator_category`:
template <typename Something>
class MyIterator {
public:
   using iterator_category = std::forward_iterator_tag;
// ...
};

// Algorithm uses `std::enable_if` (or tag dispatching, in earlier days):
template <typename FwdIter>
std::enable_if<
  // condition:
  std::is_same< std::iterator_traits<FwdIter>::iterator_category,
                std::forward_iterator_tag >,
  // return value if condition is met:
  FwdIter >::type
my_algorithm(FwdIter first, FwdIter last) {
  // ...
}
~~~

Further references:

- [Tag dispatching with iterator traits](http://en.cppreference.com/w/cpp/iterator/iterator_tags)
- [std::enable_if examples](http://en.cppreference.com/w/cpp/types/enable_if)

# Template Parameter Deduction

- Template parameters deduced from parameter types
- Return value deduced from result type


# Custom Iterators

Most custom containers require custom iterators that comply to the STL's iterator
concept.

We discussed the example `BucketHeap`
[(source)](/session-04/03-container-template/02-custom-iterators/bucket_heap.h)
which implements an
[Unrolled List](https://en.wikipedia.org/wiki/Unrolled_linked_list) in principle.

- All STL algorithms are compatible, no need to reinvent +50 algorithms for the
  user-defined class template `BucketVector`

- What if we wanted to specify a user-defined variant of an algorithm?
  $\Rightarrow$ template specialization



# Type Deduction

- The `auto` keyword
- Deduction of return types


# Template Specialization

