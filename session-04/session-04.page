---
format: Markdown
title: Session 04
category: course notes, cpppc
...

[Code Examples for Session 04](/session-04/)

# Rule of Zero

We do not need to follow the *Rule of Three* in class template `Measurements`
from assigment 02 ([source](/assignment-02/s-02/solution/measurements.h)) because
all resource management is encapsulated in the `std::vector` member.

As `std::vector` respects the *Rule of Five*, we can safely assume that its
resources will be acquired and released automatically.

- [On Rule of Zero and move assignment](http://en.cppreference.com/w/cpp/language/move_assignment)


# Function Templates

- Demonstration of STL algorithm interfaces like `std::copy`, `std::transform`,
  `std::find`
- `std::sort` for `std::list`?
- Implementing `find_nth`
- Implementing `find_if` with lambda expression


# Template Parameter Deduction

- Template parameters deduced from parameter types
- Return value deduced from result type


# BucketVector implementation

- All STL algorithms are compatible, no need to reinvent +50 algorithms for the
  user-defined class template `BucketVector`

- What if we wanted to specify a user-defined variant of an algorithm?
  $\Rightarrow$ template specialization



# Type Deduction

- The `auto` keyword
- Deduction of return types



# Temporary Copies and const-Correctness

## Return-Value Optimization

- Use references when possible, but only when possible.
- Help the compiler to use return value optimization (RVO)



# Policies vs. Inheritance

- *Composition over Inheritance* principle: compose type from behavioral aspects
- Duck-typing and relevance of concepts
- Template default arguments

# Overloading, Overwriting, Specialization


## Combinations: Tag Dispatching


# SFINAE

## Type traits

## `std::enable_if`

