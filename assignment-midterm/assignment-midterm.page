---
format: Markdown
title: Midterm Assignment
...


# 1. Types, Classes, Objects and their State

## 1.1

Assuming you are confronted with a class that supports the following
use case:

```c++
DateParser date_parser;
date_parser.set_date(today);

auto day = date_parser.day_of_week();
```

What is your objection to this? How would you change the interface of class
`DateParser`?


## 1.2

Given the following implementation of class `SemanticSurprise`:

```c++
class SemanticSurprise {
public:

  SemanticSurprise(int value)
  : _value(value) { }

  SemanticSurprise(const SemanticSurprise & other)
  : _value(other._value) { } 

  bool operator==(const SemanticSurprise & other) const {
    return _value == other._value;
  }

  int value() {
    return _value;
  }

private:
  int _value;
};
```

- Are there compiler errors? If so: why?
- Name the method/operation on `SemanticSurprise` in every line marked with
  `Op?`, including those that lead to compiler errors.
- Which values are returned in the lines marked with `value?` (given the line
  does not lead to a compiler error).
  Explain why these values are returned.
- How can this implementation be simplified? What is the requirement for
  this simplification?

```c++
SemanticSurprise s1;          // <-- Op?
s1.value();                   // <-- value?

SemanticSurprise s2(4);       // <-- Op?
s2.value();                   // <-- value?

SemanticSurprise s3 = s2;     // <-- Op?
s3.value();                   // <-- value?

SemanticSurprise s4(s3);      // <-- Op?
s4 == s3;                     // <-- value?
s2 != s3;                     // <-- value?
```

Given the implementation of `SemanticSurprise` above, the following use
case leads to a compiler error:

```c++
void print_surprise(const SemanticSurprise & s) {
  std::cout << "SemanticSurprise.value: " << s.value() << std::endl;
}

print_surprise(SemanticSurprise(10));
```

- Explain the compiler error and how the implementation of `SemanticSurprise`
  has to be corrected.


## 1.3

Consider the following use case:

```c++
// ...
if (condition) {
        LogFileReader log_reader("performance.log");
        if (log_reader.lines().size() > 1024) { return; }
}
// ...
```

- Judging from its usage illustrated above: which rule must be satisfied in
  the implementation of class `LogFileReader` (or one of its members)?
- Name a popular technique in resource management that depends on this rule,
  and briefly explain its principle.



# 2. Container Types, Class Template Basics


# 3. Iterators

The following algorithm dereferences and returns a given iterator's successor
unless the successor's referenced value matches some condition. The algorithm
is semantically correct but does not compile for iterators of some containers.
Which containers? Briefly explain why the algorithm does not work for these
and how it has to be changed.

```c++
template <typename Iterator, typename Value = typename Iterator::value_type>
Value next_value_or_default(Iterator it, Iterator end, Value default) {
  if (it == end) { return default; }
  return it[1];
}
```

# 4. Algorithms, Function Templates, Type Deduction


# 5. Sequence Containers


# 6. Thread-Safety

## 6.1 Parallel operations on STL Containers

