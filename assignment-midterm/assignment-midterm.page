---
format: Markdown
title: Midterm Assignment
...


# 1. Types, Classes, Objects and their State

## 1.1

Assuming you are confronted with a class that supports the following
use case:

```c++
DateParser date_parser;
date_parser.set_date(today);

auto day = date_parser.day_of_week();
```

What is your objection to this? How would you change the interface of class
`DateParser`?


## 1.2

Given the following implementation of class `SemanticSurprise`:

```c++
class SemanticSurprise {
public:

  SemanticSurprise(int value)
  : _value(value) { }

  SemanticSurprise(const SemanticSurprise & other)
  : _value(other._value) { } 

  bool operator==(const SemanticSurprise & other) const {
    return _value == other._value;
  }

  int value() {
    return _value;
  }

private:
  int _value;
};
```

- Are there compiler errors? If so: why?
- Name the method/operation on `SemanticSurprise` in every line marked with
  `Op?`, including those that lead to compiler errors.
- Which values are returned in the lines marked with `value?` (given the line
  does not lead to a compiler error).
  Explain why these values are returned.
- How can this implementation be simplified? What is the requirement for
  this simplification?

```c++
SemanticSurprise s1;          // <-- Op?
s1.value();                   // <-- value?

SemanticSurprise s2(4);       // <-- Op?
s2.value();                   // <-- value?

SemanticSurprise s3 = s2;     // <-- Op?
s3.value();                   // <-- value?

SemanticSurprise s4(s3);      // <-- Op?
s4 == s3;                     // <-- value?
s2 != s3;                     // <-- value?
```

Given the implementation of `SemanticSurprise` above, the following use
case leads to a compiler error:

```c++
void print_surprise(const SemanticSurprise & s) {
  std::cout << "SemanticSurprise.value: " << s.value() << std::endl;
}

print_surprise(SemanticSurprise(10));
```

- Explain the compiler error and how the implementation of `SemanticSurprise`
  has to be corrected.


## 1.3

Consider the following use case:

```c++
// ...
if (condition) {
        LogFileReader log_reader("performance.log");
        if (log_reader.lines().size() > 1024) { return; }
}
// ...
```

- Judging from its usage illustrated above: which rule must be satisfied in
  the implementation of class `LogFileReader` (or one of its members)?
- Name a popular technique in resource management that depends on this rule,
  and briefly explain its principle.



# 2. Container Types, Class Template Basics



# 3. Iterators

The following algorithm dereferences and returns a given iterator's successor
unless the successor's referenced value matches some condition. The algorithm
is semantically correct but does not compile for iterators of some containers.
Which containers? Briefly explain why the algorithm does not work for these
and how it has to be changed.

```c++
template <typename Iterator, typename Value = typename Iterator::value_type>
Value next_value_or_default(Iterator it, Iterator end, Value default) {
  if (it == end) { return default; }
  return it[1];
}
```


# 4. Debugging

Use gdb to debug the program implemented in the attached source file
`a-midterm/debug.cc`. Running the program leads to a segfault.

- Use gdb to determine the source code location (stack trace) of the
  statement that causes the segmentation violation fault. Attach a
  screenshot or plaintext copy of gdb's output.



# 5. Algorithms, Function Templates, Type Deduction


# 6. STL-Compatible Sequence Containers


# 7. Thread-Safety

## 7.1 Parallelism and STL Containers

Given the following operations on an instance of `std::vector`, consider
operations in the same table row to be executed by multiple threads in
parallel:

```c++
// Shared vector instance accessed by thread A and thread B:
std::vector<int> v;

// thread A:                    | thread B:
// =============================|==============================
   std::vector<int> a;          | std::vector<int> b;
// -----------------------------+------------------------------
   int xa = v[3];               | int xb = v[4];
// -----------------------------+------------------------------
   v[3] = 123;                  | v[4] = 345;
// -----------------------------+------------------------------
   v[3] = 123;                  | int xb = v[3];
// -----------------------------+------------------------------
   v.push_back(24);             | v.size();
// -----------------------------+------------------------------
   v.back();                    | v.push_back(54);
// -----------------------------+------------------------------
   v.begin();                   | v.push_back(34);
// -----------------------------+------------------------------
   v.back();                    | v.pop_back();
// -----------------------------+------------------------------
```

- For every pair of operation on the same table row, give a brief
  explanation on the guarantees with respect to thread-safety according to
  the C++ standard.



