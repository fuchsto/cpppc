---
format: Markdown
title: Assignment 4: Thread Safety
categories: cpppc, teaching
...

**C++ Programming Course, Winter Term 2016**


[Source Code](/assignment-04/a-04/)


# 4-0: Standardese: Thread-Safety of STL Containers

Briefly put: **Modifying operations** on STL containers are not thread safe.
And with good reason:

Thread safety drastically increases the complexity of even the most
fundamental operations on containers.
Extending the C++ standard library by thread-safe container alternatives is
not feasible either as any single parallel container implementation would
only satisfy the requirements of singular use cases.

For the forseeable future, we will have to implement concurrent data
structures ourselves once in a while, at least if we want to maximize
performance for a specific use case.

However, the C++ standard specifies guarantees to thread safety for *some*
operations. Read the subsection *Thread Safety* on this page **thoroughly**:

<http://en.cppreference.com/w/cpp/container>

Be not afraid.

Find examples for every item in the article to illustrate use cases where
thread safety is guaranteed, and those that may lead to race conditions
according to the C++ standard.

The text might be overwhelming and alienating at first, but the more
examples you write down, the better your eyes will adapt to the blinding
light of the "standardese" phrasing.



# 4-1: Lock-based Pool

The most basic container specified in the STL is `std::set`.
In this assignment, we reduce the set concept even more. A `pool` (or `bag`)
is a set that does not remove and return a *specified* element in its
`get` operation, but *any* element.

Expression      | Synopsis
--------------- | ------------------------------------------------------------
`p.insert(e)   `| Adds element `e` to the pool, error if `e` is already in `p`
`p.take() -> e `| Removes and returns any element `e` from the pool.


Pools are essential to parallel applications but not specified in the STL.
A pool is neither sequential (i.e. no `begin`, `end`) nor associative (i.e.
no `at`, `find`, ...).

Implement a thread-safe container `lpool` using lock-based synchronization
such as `std::mutex` and related constructs like `std::lock_guard`.


# 4-2: Lock-free Pool

Implement a variant of the thread-safe pool container `apool` with identical
behavior, but based on atomic operations.

A correct solution is surprisingly simple - but not trivial!

In fact, one would invest three pages in a [master's thesis](http://www.mnm-team.org/~fuchst/master_thesis_tobias_fuchs.pdf) to discuss it.


**Hint:**

The C++ container collection in the excellent Siemens EMBB library provides
lock- and wait-free pools. For compatibility reasons, these are not based on `std::atomic` of "modern C++", however.

Try to understand their basic principle and port it to `C++11`:

- [Siemens EMBB](https://github.com/siemens/embb/tree/benchmark/containers_cpp/include/embb/containers)
- [EMBB experimental containers](https://github.com/fuchsto/embb/tree/benchmark/containers_cpp/include/embb/containers)



